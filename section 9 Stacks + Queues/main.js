//Stacks

//goolge
//udemy
//youtube

//Can be implemented by using
//Arrays: allows cache locallity making it faster when accessing its items in memory because they are right next to each other verus a linked list that has them scattered all over memory.
//Linked Lists:


// 스택(Stack)은 데이터를 일시적으로 저장하는 자료구조 중 하나로, 후입선출(LIFO) 구조를 가지고 있습니다. 스택을 구현할 때, 배열(Array)과 연결리스트(Linked List) 두 가지 방법을 주로 사용합니다.

// 배열(Array)을 사용하는 스택 구현의 장점은 다음과 같습니다:

// 구현이 간단하고 직관적입니다. 배열의 인덱스를 이용해 스택의 요소를 접근하므로, 구현이 용이합니다.
// 메모리 공간을 연속적으로 사용하므로, 캐시 효율성이 높아 성능이 우수합니다.
// 요소의 접근이 O(1) 시간에 가능합니다. 인덱스를 이용해 직접 접근하므로, 검색 시간이 매우 빠릅니다.
// 반면, 연결리스트(Linked List)를 사용하는 스택 구현의 장점은 다음과 같습니다:

// 동적으로 메모리 공간을 할당하므로, 스택의 크기가 동적으로 변할 수 있습니다.
// 삽입과 삭제가 상수 시간(O(1))에 가능합니다. 스택의 맨 앞에 노드를 추가하거나 삭제하는 경우, 배열보다 효율적입니다.
// 불필요한 메모리 공간을 사용하지 않습니다. 배열의 경우, 초기 크기를 할당하고 필요한 공간보다 많은 메모리를 사용할 가능성이 있습니다. 반면, 연결리스트는 동적으로 메모리 공간을 할당하므로, 필요한 만큼의 공간만 사용합니다.
// 따라서, 배열을 사용하는 스택 구현은 구현이 쉽고 요소의 접근이 빠르지만, 크기를 동적으로 조정하기 어렵고 삽입과 삭제가 비효율적입니다. 반면, 연결리스트를 사용하는 스택 구현은 크기를 동적으로 조정할 수 있으며, 삽입과 삭제가 효율적이지만, 요소의 접근이 느리고 구현이 복잡합니다. 따라서, 스택을 구현할 때는 사용하고자 하는 상황과 용도에 따라 적절한 자료구조를 선택해야 합니다

// Queues
Head                      tail 
Matt -- Joy -- Samir -- Pavel

//Linked Lists

// Queue는 데이터를 일시적으로 저장하는 자료구조 중 하나로, 선입선출(FIFO) 구조를 가지고 있습니다. Queue를 구현할 때, 배열(Array)을 사용하는 것은 일반적으로 권장되지 않습니다. 그 이유는 다음과 같습니다.

// 크기 제한이 있습니다.
// 배열은 미리 정해진 크기만큼의 메모리 공간을 할당받습니다. Queue는 동적으로 크기가 변할 수 있기 때문에, 배열을 사용하면 Queue의 크기를 동적으로 조절하기 어렵습니다. 만약 Queue의 크기를 초과하면, 새로운 요소를 추가할 수 없습니다.

// 요소의 삽입과 삭제가 비효율적입니다.
// Queue에서는 맨 앞의 요소를 삭제하거나, 맨 뒤에 요소를 삽입하는 작업이 자주 일어납니다. 배열에서는 맨 앞에 요소를 삭제하거나, 맨 뒤에 요소를 추가하는 경우 모든 요소를 이동해야 합니다. 이 작업은 매우 비효율적이며, 시간이 오래 걸릴 수 있습니다.

// 메모리 낭비가 발생할 수 있습니다.
// Queue의 크기가 동적으로 변할 수 있기 때문에, 배열의 크기를 충분히 크게 할당해야 합니다. 이 경우, Queue가 실제로 사용하는 메모리보다 더 많은 메모리를 사용하게 되므로, 메모리 낭비가 발생할 수 있습니다.

// 따라서, Queue를 구현할 때는 배열 대신 연결리스트(Linked List)를 사용하는 것이 일반적으로 권장됩니다. 연결리스트는 동적으로 메모리 공간을 할당하므로 크기가 동적으로 조절할 수 있으며, 요소의 삽입과 삭제가 효율적입니다. 또한, 메모리 낭비가 발생하지 않습니다.